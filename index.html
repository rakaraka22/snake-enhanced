<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake Recharged</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Manrope:wght@500;700;800&display=swap');

    :root {
      --bg-1: #f4f8ff;
      --bg-2: #eefaf2;
      --bg-3: #fff6e9;
      --ink: #14324f;
      --muted: #4f6782;
      --panel: rgba(255, 255, 255, 0.74);
      --panel-border: rgba(38, 98, 154, 0.22);
      --accent: #0fae7d;
      --accent-2: #ff8a4c;
      --canvas-border: rgba(255, 255, 255, 0.6);
      --surface-soft: rgba(255, 255, 255, 0.68);
      --surface-strong: rgba(255, 255, 255, 0.88);
      --button-text: #1b4770;
      --chip-border: rgba(52, 118, 175, 0.2);
      --chip-text: #376187;
      --stat-text: #4e6985;
      --help-text: #456380;
      --board-bg-a: #dff0ff;
      --board-bg-b: #b8ddff;
      --board-checker: rgba(255, 255, 255, 0.22);
      --board-grid: rgba(35, 95, 143, 0.2);
      --board-vignette: rgba(15, 46, 77, 0.16);
      --board-sweep: rgba(255, 255, 255, 0.22);
      --board-spark: rgba(255, 255, 255, 0.82);
      --board-frame: rgba(255, 255, 255, 0.42);
      --canvas-inset: inset 0 0 24px rgba(11, 40, 70, 0.15);
      --canvas-drop: 0 12px 30px rgba(22, 53, 87, 0.24);
    }

    :root[data-theme='dark'] {
      --bg-1: #04121d;
      --bg-2: #071b2a;
      --bg-3: #0b111f;
      --ink: #d7e6f7;
      --muted: #9eb8d4;
      --panel: rgba(8, 20, 34, 0.78);
      --panel-border: rgba(142, 201, 255, 0.24);
      --canvas-border: rgba(134, 197, 255, 0.5);
      --surface-soft: rgba(19, 38, 59, 0.72);
      --surface-strong: rgba(31, 54, 80, 0.86);
      --button-text: #d7e9ff;
      --chip-border: rgba(140, 194, 240, 0.34);
      --chip-text: #cae4ff;
      --stat-text: #a9c7e6;
      --help-text: #9cbadd;
      --board-bg-a: #03132a;
      --board-bg-b: #061f34;
      --board-checker: rgba(102, 184, 255, 0.06);
      --board-grid: rgba(149, 207, 255, 0.1);
      --board-vignette: rgba(0, 0, 0, 0.35);
      --board-sweep: rgba(123, 206, 255, 0.12);
      --board-spark: rgba(175, 229, 255, 0.66);
      --board-frame: rgba(120, 191, 255, 0.26);
      --canvas-inset: inset 0 0 34px rgba(0, 0, 0, 0.44);
      --canvas-drop: 0 12px 30px rgba(10, 26, 44, 0.46);
    }

    * {
      box-sizing: border-box;
    }

    html {
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
    }

    body {
      margin: 0;
      min-height: 100vh;
      min-height: 100svh;
      height: 100svh;
      display: grid;
      place-items: center;
      overflow: hidden;
      font-family: 'Manrope', 'Trebuchet MS', sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 12% 18%, rgba(79, 210, 170, 0.34), transparent 42%),
        radial-gradient(circle at 85% 8%, rgba(255, 167, 102, 0.28), transparent 38%),
        radial-gradient(circle at 80% 80%, rgba(125, 178, 255, 0.2), transparent 48%),
        linear-gradient(145deg, var(--bg-1), var(--bg-2) 56%, var(--bg-3));
      padding-top: calc(14px + env(safe-area-inset-top));
      padding-right: calc(12px + env(safe-area-inset-right));
      padding-bottom: calc(14px + env(safe-area-inset-bottom));
      padding-left: calc(12px + env(safe-area-inset-left));
      transition: background 200ms ease, color 200ms ease;
      overscroll-behavior: none;
    }

    .ambient {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      overflow: hidden;
    }

    .blob {
      position: absolute;
      border-radius: 999px;
      filter: blur(12px);
      opacity: 0.55;
      animation: drift 14s ease-in-out infinite;
    }

    .blob-a {
      width: 270px;
      height: 270px;
      background: rgba(53, 188, 255, 0.28);
      top: -60px;
      left: 4%;
    }

    .blob-b {
      width: 320px;
      height: 320px;
      background: rgba(255, 169, 86, 0.26);
      right: -80px;
      top: 10%;
      animation-delay: -6s;
    }

    .blob-c {
      width: 220px;
      height: 220px;
      background: rgba(70, 220, 154, 0.2);
      bottom: 2%;
      left: 18%;
      animation-delay: -3s;
    }

    @keyframes drift {
      0%,
      100% {
        transform: translate3d(0, 0, 0) scale(1);
      }
      50% {
        transform: translate3d(12px, -16px, 0) scale(1.05);
      }
    }

    .app {
      width: min(97vw, 880px);
      height: min(100%, 940px);
      position: relative;
      border-radius: 24px;
      border: 1px solid var(--panel-border);
      background: var(--panel);
      box-shadow:
        0 24px 42px rgba(19, 59, 100, 0.17),
        inset 0 1px 0 rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(8px);
      overflow: hidden;
      display: grid;
      grid-template-rows: 1fr;
    }

    .menu-screen {
      position: absolute;
      inset: 14px;
      z-index: 8;
      border-radius: 18px;
      padding: 24px;
      background:
        linear-gradient(130deg, rgba(247, 253, 255, 0.96), rgba(244, 252, 247, 0.96));
      border: 1px solid rgba(57, 128, 188, 0.23);
      box-shadow:
        0 18px 30px rgba(0, 0, 0, 0.14),
        inset 0 1px 0 rgba(255, 255, 255, 0.95);
      display: grid;
      gap: 14px;
      align-content: center;
      justify-items: center;
      text-align: center;
      transition: opacity 170ms ease, transform 170ms ease;
    }

    .menu-screen.hidden {
      opacity: 0;
      transform: translateY(8px) scale(0.985);
      pointer-events: none;
    }

    .eyebrow {
      margin: 0;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      font-size: 11px;
      font-weight: 800;
      color: #2a5f8b;
    }

    h1 {
      margin: 0;
      font-family: 'Orbitron', 'Manrope', sans-serif;
      font-size: clamp(32px, 5.4vw, 52px);
      line-height: 1;
      letter-spacing: 0.04em;
      color: #0f3358;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.95);
    }

    .intro {
      margin: 0;
      color: var(--muted);
      max-width: 58ch;
      font-size: 15px;
    }

    .block-title {
      margin: 0;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #375c80;
      font-weight: 800;
    }

    .mode-picker {
      display: flex;
      align-items: stretch;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--chip-border);
      background: var(--surface-soft);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.9);
      width: min(100%, 360px);
    }

    .mode-button {
      border: 0;
      border-right: 1px solid var(--chip-border);
      background: transparent;
      color: var(--chip-text);
      font: 700 13px/1 'Manrope', sans-serif;
      min-width: 0;
      flex: 1 1 0;
      padding: 9px 14px;
      cursor: pointer;
      transition: color 130ms ease, background 130ms ease;
    }

    .mode-button:last-child {
      border-right: 0;
    }

    .mode-button:hover {
      color: var(--button-text);
      background: rgba(81, 171, 239, 0.11);
    }

    .mode-button.active {
      color: #fff;
      background: linear-gradient(160deg, #3ca6f5, #2ad39d);
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.26);
    }

    .cta {
      border: 0;
      border-radius: 12px;
      padding: 12px 16px;
      font: 800 14px/1 'Manrope', sans-serif;
      color: #fff;
      background: linear-gradient(145deg, #15b682, #1d95f0);
      cursor: pointer;
      box-shadow:
        0 14px 24px rgba(24, 155, 221, 0.28),
        inset 0 -1px 0 rgba(0, 0, 0, 0.16);
      width: fit-content;
    }

    .cta:hover {
      filter: brightness(1.05);
    }

    .scores {
      margin-top: 4px;
      display: grid;
      gap: 10px;
      width: min(100%, 560px);
    }

    .score-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .score-card {
      border-radius: 12px;
      border: 1px solid var(--chip-border);
      background: var(--surface-soft);
      padding: 10px 12px;
      display: grid;
      gap: 2px;
    }

    .score-card span {
      font-size: 12px;
      color: #4a6785;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      font-weight: 700;
    }

    .score-card strong {
      font: 800 22px/1 'Orbitron', sans-serif;
      color: #173a60;
    }

    .last-run {
      margin: 4px 0 0;
      font-size: 14px;
      color: #32577b;
      font-weight: 700;
      text-align: center;
    }

    .game-shell {
      display: grid;
      grid-template-rows: auto minmax(0, 1fr) auto auto;
      gap: 8px;
      padding: 16px;
      height: 100%;
      min-height: 0;
      align-content: start;
    }

    .hud {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }

    .stat {
      min-width: 88px;
      border-radius: 10px;
      border: 1px solid var(--chip-border);
      background: var(--surface-soft);
      padding: 6px 9px;
      display: grid;
      gap: 1px;
    }

    .stat span {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--stat-text);
      font-weight: 700;
    }

    .stat strong {
      font: 800 15px/1 'Orbitron', sans-serif;
      color: #18395a;
    }

    .hud-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      row-gap: 8px;
    }

    /* Gameplay header buttons are intentionally removed to maximize board space. */
    .hud-actions {
      display: none !important;
    }

    .mode-picker.compact {
      flex: 1 1 320px;
      max-width: 420px;
      width: 100%;
    }

    .mode-picker.compact .mode-button {
      padding: 8px 12px;
      font-size: 12px;
    }

    .btn {
      border: 1px solid var(--chip-border);
      background: var(--surface-soft);
      color: var(--button-text);
      border-radius: 10px;
      padding: 9px 12px;
      font: 700 13px/1 'Manrope', sans-serif;
      cursor: pointer;
    }

    .btn:hover {
      background: var(--surface-strong);
    }

    .btn.ghost {
      background: var(--surface-soft);
    }

    canvas {
      width: min(100%, clamp(230px, min(94vw, 70svh), 680px));
      height: auto;
      aspect-ratio: 1;
      display: block;
      margin-inline: auto;
      align-self: center;
      border-radius: 16px;
      border: 1px solid var(--canvas-border);
      background: var(--board-bg-a);
      box-shadow: var(--canvas-inset), var(--canvas-drop);
      touch-action: none;
    }

    .help {
      margin: 0;
      color: var(--help-text);
      font-size: 13px;
      font-weight: 700;
      text-align: center;
    }

    .theme-toggle {
      min-width: 110px;
      text-align: center;
    }

    .touch-controls {
      width: 100%;
      display: none;
      justify-content: center;
      align-items: end;
      gap: 12px;
      margin-top: 2px;
      touch-action: manipulation;
    }

    body.touch-device .touch-controls {
      display: flex;
    }

    body.touch-device .help {
      display: none;
    }

    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 74px);
      grid-template-rows: repeat(3, 74px);
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      gap: 10px;
    }

    .touch-btn {
      border: 1px solid var(--chip-border);
      background: var(--surface-soft);
      color: var(--button-text);
      border-radius: 14px;
      min-height: 62px;
      min-width: 62px;
      padding: 0 10px;
      font: 800 18px/1 'Manrope', sans-serif;
      letter-spacing: 0.02em;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      cursor: pointer;
    }

    .touch-btn:active {
      transform: translateY(1px) scale(0.98);
      background: var(--surface-strong);
    }

    .touch-btn.dir-up {
      grid-area: up;
      font-size: 30px;
    }

    .touch-btn.dir-left {
      grid-area: left;
      font-size: 30px;
    }

    .touch-btn.dir-right {
      grid-area: right;
      font-size: 30px;
    }

    .touch-btn.dir-down {
      grid-area: down;
      font-size: 30px;
    }

    :root[data-theme='dark'] .menu-screen {
      background: linear-gradient(130deg, rgba(13, 28, 45, 0.94), rgba(12, 33, 37, 0.94));
      border-color: rgba(132, 194, 255, 0.22);
      box-shadow: 0 18px 30px rgba(0, 0, 0, 0.42), inset 0 1px 0 rgba(255, 255, 255, 0.07);
    }

    :root[data-theme='dark'] .eyebrow,
    :root[data-theme='dark'] .block-title,
    :root[data-theme='dark'] .score-card span,
    :root[data-theme='dark'] .last-run {
      color: #a9c8e5;
    }

    :root[data-theme='dark'] h1,
    :root[data-theme='dark'] .score-card strong,
    :root[data-theme='dark'] .stat strong {
      color: #e9f4ff;
      text-shadow: none;
    }

    @media (max-width: 760px) {
      .menu-screen {
        padding: 18px;
        inset: 10px;
      }

      .score-grid {
        grid-template-columns: 1fr;
      }

      .hud {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .stats {
        width: 100%;
        justify-content: space-between;
      }

      .hud-actions {
        width: 100%;
        justify-content: stretch;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }

      .mode-picker.compact {
        grid-column: 1 / -1;
        max-width: none;
      }

      .hud-actions .btn {
        width: 100%;
      }

      canvas {
        width: min(100%, clamp(190px, min(92vw, 64svh), 560px));
      }
    }

    @media (max-width: 500px) {
      .game-shell {
        padding: 12px;
        gap: 8px;
      }

      .mode-picker.compact {
        flex-basis: 100%;
      }

      .mode-picker.compact .mode-button {
        flex: 1;
      }

      .theme-toggle {
        width: 100%;
      }

      .stats {
        gap: 6px;
      }

      .stat {
        min-width: 0;
        flex: 1;
      }

      .touch-controls {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .dpad {
        align-self: center;
        grid-template-columns: repeat(3, 68px);
        grid-template-rows: repeat(3, 68px);
        gap: 6px;
      }

      canvas {
        width: min(100%, clamp(170px, min(90vw, 60svh), 500px));
      }
    }

    body.touch-device #menuBtn,
    body.touch-device #themeToggleHud {
      display: none;
    }

    body.touch-device .hud-actions {
      grid-template-columns: 1fr;
    }

    @media (max-height: 760px) and (orientation: portrait) {
      .menu-screen {
        inset: 8px;
        padding: 12px;
        gap: 8px;
      }

      h1 {
        font-size: clamp(28px, 5vh, 40px);
      }

      .intro {
        font-size: 13px;
        max-width: 46ch;
      }

      .score-card strong {
        font-size: 18px;
      }

      canvas {
        width: min(100%, clamp(150px, min(86vw, 50svh), 460px));
      }

      .touch-btn {
        min-height: 52px;
      }

      .dpad {
        grid-template-columns: repeat(3, 58px);
        grid-template-rows: repeat(3, 58px);
        gap: 6px;
      }

      .help {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="ambient" aria-hidden="true">
    <span class="blob blob-a"></span>
    <span class="blob blob-b"></span>
    <span class="blob blob-c"></span>
  </div>

  <main class="app">
    <section id="menuScreen" class="menu-screen" aria-hidden="false">
      <p class="eyebrow">Classic Arcade</p>
      <h1>Snake Recharged</h1>
      <p class="intro">
        Eat, grow, and stay alive. Pick your difficulty, then hit start. Scores are saved per mode so you can chase new personal bests.
      </p>

      <p class="block-title">Difficulty</p>
      <div class="mode-picker" role="group" aria-label="Select difficulty">
        <button type="button" class="mode-button" data-mode="easy">Easy</button>
        <button type="button" class="mode-button active" data-mode="medium">Medium</button>
        <button type="button" class="mode-button" data-mode="hard">Hard</button>
      </div>

      <button id="startBtn" class="cta" type="button">Start Game</button>

      <section class="scores" aria-label="High scores">
        <p class="block-title">High Scores</p>
        <div class="score-grid">
          <article class="score-card"><span>Easy</span><strong id="hsEasy">0</strong></article>
          <article class="score-card"><span>Medium</span><strong id="hsMedium">0</strong></article>
          <article class="score-card"><span>Hard</span><strong id="hsHard">0</strong></article>
          <article class="score-card"><span>Overall</span><strong id="hsOverall">0</strong></article>
        </div>
      </section>

      <p id="lastRun" class="last-run">No runs yet. Start your first game.</p>
      <button id="themeToggleMenu" class="btn ghost theme-toggle" type="button">Dark Mode</button>
    </section>

    <section class="game-shell">
      <header class="hud">
        <div class="stats" aria-live="polite">
          <div class="stat"><span>Score</span><strong id="score">0</strong></div>
          <div class="stat"><span>Best</span><strong id="best">0</strong></div>
          <div class="stat"><span>Mode</span><strong id="modeLabel">Medium</strong></div>
        </div>

        <div class="hud-actions">
          <div class="mode-picker compact" role="group" aria-label="Change difficulty">
            <button type="button" class="mode-button" data-mode="easy">Easy</button>
            <button type="button" class="mode-button active" data-mode="medium">Medium</button>
            <button type="button" class="mode-button" data-mode="hard">Hard</button>
          </div>
          <button id="restartBtn" class="btn" type="button">Restart</button>
          <button id="themeToggleHud" class="btn ghost theme-toggle" type="button">Dark Mode</button>
          <button id="menuBtn" class="btn ghost" type="button">Menu</button>
        </div>
      </header>

      <canvas id="board" width="480" height="480" aria-label="Snake game board"></canvas>
      <section id="touchControls" class="touch-controls" aria-label="Touch controls">
        <div class="dpad" role="group" aria-label="Direction controls">
          <button type="button" class="touch-btn dir-up" data-touch-dir="up" aria-label="Move up">↑</button>
          <button type="button" class="touch-btn dir-left" data-touch-dir="left" aria-label="Move left">←</button>
          <button type="button" class="touch-btn dir-right" data-touch-dir="right" aria-label="Move right">→</button>
          <button type="button" class="touch-btn dir-down" data-touch-dir="down" aria-label="Move down">↓</button>
        </div>
      </section>
      <p class="help">Arrow keys/WASD on desktop. On iPhone, use the on-screen D-pad. Golden apples appear for 5 seconds and give bonus points.</p>
    </section>
  </main>

  <script>
    (() => {
      const GRID = 24;
      const CELLS = 20;
      const BOARD = GRID * CELLS;
      const STORAGE_KEY = 'snake-high-scores-v1';
      const THEME_KEY = 'snake-theme-v1';
      const REGULAR_FOOD_POINTS = 10;
      const SPECIAL_FOOD_POINTS = 35;
      const SPECIAL_FOOD_DURATION_MS = 5000;
      const SPECIAL_FOOD_SPAWN_CHANCE = 0.3;
      const SPECIAL_FOOD_COOLDOWN_MS = 7000;
      const TAU = Math.PI * 2;
      const WRAP_GAP_THRESHOLD = GRID * 1.6;

      const MODES = {
        easy: {
          label: 'Easy',
          startSpeed: 175,
          minSpeed: 110,
          speedStep: 2,
          hue: 174
        },
        medium: {
          label: 'Medium',
          startSpeed: 130,
          minSpeed: 72,
          speedStep: 3,
          hue: 140
        },
        hard: {
          label: 'Hard',
          startSpeed: 95,
          minSpeed: 48,
          speedStep: 4,
          hue: 28
        }
      };

      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');

      const menuScreen = document.getElementById('menuScreen');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      const menuBtn = document.getElementById('menuBtn');
      const themeToggleMenuBtn = document.getElementById('themeToggleMenu');
      const themeToggleHudBtn = document.getElementById('themeToggleHud');
      const touchDirectionButtons = Array.from(document.querySelectorAll('[data-touch-dir]'));
      const modeButtons = Array.from(document.querySelectorAll('.mode-button'));

      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const modeLabelEl = document.getElementById('modeLabel');
      const lastRunEl = document.getElementById('lastRun');

      const hsEasyEl = document.getElementById('hsEasy');
      const hsMediumEl = document.getElementById('hsMedium');
      const hsHardEl = document.getElementById('hsHard');
      const hsOverallEl = document.getElementById('hsOverall');

      let snake = [];
      let direction = { x: 1, y: 0 };
      let directionQueue = [];
      let food = { x: 12, y: 8 };
      let specialFood = null;
      let specialFoodCooldownUntil = 0;
      let score = 0;
      let speed = MODES.medium.startSpeed;
      let tickTimer = null;
      let animationFrame = null;
      let paused = false;
      let gameOver = false;
      let started = false;
      let currentMode = 'medium';
      let lastRun = null;
      let highScores = loadHighScores();
      let particles = [];
      let overlayTitle = '';
      let overlaySubtitle = '';
      let lastFrameTime = performance.now();
      let lastStepAt = performance.now();
      let theme = 'dark';
      let previousSnake = [];
      let boardTheme = {};

      function loadHighScores() {
        const defaults = { easy: 0, medium: 0, hard: 0 };

        try {
          const parsed = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
          return {
            easy: Number.isFinite(parsed.easy) ? Math.max(0, Math.floor(parsed.easy)) : 0,
            medium: Number.isFinite(parsed.medium) ? Math.max(0, Math.floor(parsed.medium)) : 0,
            hard: Number.isFinite(parsed.hard) ? Math.max(0, Math.floor(parsed.hard)) : 0
          };
        } catch {
          return defaults;
        }
      }

      function saveHighScores() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(highScores));
      }

      function detectInitialTheme() {
        const saved = localStorage.getItem(THEME_KEY);
        if (saved === 'light' || saved === 'dark') {
          return saved;
        }

        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }

      function applyTheme(nextTheme) {
        theme = nextTheme === 'light' ? 'light' : 'dark';
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem(THEME_KEY, theme);
        refreshBoardTheme();

        const label = theme === 'dark' ? 'Light Mode' : 'Dark Mode';
        themeToggleMenuBtn.textContent = label;
        themeToggleHudBtn.textContent = label;
      }

      function refreshBoardTheme() {
        const style = getComputedStyle(document.documentElement);
        boardTheme = {
          bgA: style.getPropertyValue('--board-bg-a').trim() || '#03132a',
          bgB: style.getPropertyValue('--board-bg-b').trim() || '#061f34',
          checker: style.getPropertyValue('--board-checker').trim() || 'rgba(102, 184, 255, 0.06)',
          grid: style.getPropertyValue('--board-grid').trim() || 'rgba(149, 207, 255, 0.1)',
          vignette: style.getPropertyValue('--board-vignette').trim() || 'rgba(0, 0, 0, 0.35)',
          sweep: style.getPropertyValue('--board-sweep').trim() || 'rgba(123, 206, 255, 0.12)',
          spark: style.getPropertyValue('--board-spark').trim() || 'rgba(175, 229, 255, 0.66)',
          frame: style.getPropertyValue('--board-frame').trim() || 'rgba(120, 191, 255, 0.26)'
        };
      }

      function toggleTheme() {
        applyTheme(theme === 'dark' ? 'light' : 'dark');
      }

      function detectTouchInterface() {
        return window.matchMedia('(hover: none) and (pointer: coarse)').matches || navigator.maxTouchPoints > 0;
      }

      function syncTouchMode() {
        document.body.classList.toggle('touch-device', detectTouchInterface());
      }

      function overallHighScore() {
        return Math.max(highScores.easy, highScores.medium, highScores.hard);
      }

      function renderHighScoreCards() {
        hsEasyEl.textContent = highScores.easy;
        hsMediumEl.textContent = highScores.medium;
        hsHardEl.textContent = highScores.hard;
        hsOverallEl.textContent = overallHighScore();
      }

      function renderLastRun() {
        if (!lastRun) {
          lastRunEl.textContent = 'No runs yet. Start your first game.';
          return;
        }

        lastRunEl.textContent = `Last run: ${lastRun.score} points on ${MODES[lastRun.mode].label}.`;
      }

      function renderHud() {
        scoreEl.textContent = score;
        bestEl.textContent = Math.max(highScores[currentMode], score);
        modeLabelEl.textContent = MODES[currentMode].label;
      }

      function setMode(mode) {
        if (!MODES[mode]) return;

        currentMode = mode;
        modeButtons.forEach((button) => {
          button.classList.toggle('active', button.dataset.mode === mode);
        });
        renderHud();
      }

      function showMenu() {
        started = false;
        paused = false;
        stopTickLoop();
        menuScreen.classList.remove('hidden');
        menuScreen.setAttribute('aria-hidden', 'false');
      }

      function hideMenu() {
        menuScreen.classList.add('hidden');
        menuScreen.setAttribute('aria-hidden', 'true');
      }

      function startGame() {
        started = true;
        hideMenu();
        resetRound();
      }

      function randomCell() {
        return Math.floor(Math.random() * CELLS);
      }

      function cellKey(x, y) {
        return `${x},${y}`;
      }

      function pickFreeCell({ avoidFood = true, avoidSpecialFood = true } = {}) {
        const occupied = new Set(snake.map((segment) => cellKey(segment.x, segment.y)));

        if (avoidFood && food) {
          occupied.add(cellKey(food.x, food.y));
        }

        if (avoidSpecialFood && specialFood) {
          occupied.add(cellKey(specialFood.x, specialFood.y));
        }

        const freeCount = CELLS * CELLS - occupied.size;
        if (freeCount <= 0) {
          return null;
        }

        const choice = Math.floor(Math.random() * freeCount);
        let cursor = 0;

        for (let y = 0; y < CELLS; y++) {
          for (let x = 0; x < CELLS; x++) {
            if (occupied.has(cellKey(x, y))) continue;
            if (cursor === choice) return { x, y };
            cursor += 1;
          }
        }

        return null;
      }

      function spawnFood() {
        const next = pickFreeCell({ avoidFood: false, avoidSpecialFood: true });
        if (!next) {
          endRound(true);
          return;
        }

        food = next;
      }

      function spawnSpecialFood(now) {
        if (specialFood) return;
        if (now < specialFoodCooldownUntil) return;
        if (Math.random() > SPECIAL_FOOD_SPAWN_CHANCE) return;

        const next = pickFreeCell({ avoidFood: true, avoidSpecialFood: false });
        if (!next) return;

        specialFood = {
          x: next.x,
          y: next.y,
          expiresAt: now + SPECIAL_FOOD_DURATION_MS
        };
        specialFoodCooldownUntil = now + SPECIAL_FOOD_COOLDOWN_MS;
      }

      function updateSpecialFoodExpiry(now) {
        if (specialFood && now >= specialFood.expiresAt) {
          specialFood = null;
        }
      }

      function resetRound() {
        const middle = Math.floor(CELLS / 2);

        snake = [
          { x: middle, y: middle },
          { x: middle - 1, y: middle },
          { x: middle - 2, y: middle }
        ];

        direction = { x: 1, y: 0 };
        directionQueue = [];
        score = 0;
        speed = MODES[currentMode].startSpeed;
        specialFood = null;
        specialFoodCooldownUntil = 0;
        paused = false;
        gameOver = false;
        particles = [];
        overlayTitle = '';
        overlaySubtitle = '';
        previousSnake = snake.map((segment) => ({ x: segment.x, y: segment.y }));
        lastStepAt = performance.now();

        spawnFood();
        renderHud();
        startTickLoop();
      }

      function startTickLoop() {
        stopTickLoop();
        tickTimer = setInterval(step, speed);
      }

      function stopTickLoop() {
        if (!tickTimer) return;
        clearInterval(tickTimer);
        tickTimer = null;
      }

      function setDirection(next) {
        if (!started || gameOver) return;

        const plannedDirection = directionQueue.length
          ? directionQueue[directionQueue.length - 1]
          : direction;
        const isSame = plannedDirection.x === next.x && plannedDirection.y === next.y;
        const isReverse = plannedDirection.x + next.x === 0 && plannedDirection.y + next.y === 0;
        if (isSame || isReverse) return;

        if (directionQueue.length < 3) {
          directionQueue.push(next);
        }
      }

      function setDirectionFromToken(token) {
        if (token === 'up') setDirection({ x: 0, y: -1 });
        if (token === 'down') setDirection({ x: 0, y: 1 });
        if (token === 'left') setDirection({ x: -1, y: 0 });
        if (token === 'right') setDirection({ x: 1, y: 0 });
      }

      function togglePause() {
        if (!(started && !gameOver)) return;
        paused = !paused;

        if (paused) {
          stopTickLoop();
        } else {
          startTickLoop();
        }
      }

      function bindTouchControl(element, handler) {
        let ignoreMouseUntil = 0;

        element.addEventListener(
          'touchstart',
          (event) => {
            ignoreMouseUntil = Date.now() + 700;
            event.preventDefault();
            handler();
          },
          { passive: false }
        );

        element.addEventListener('mousedown', (event) => {
          if (Date.now() < ignoreMouseUntil) return;
          event.preventDefault();
          handler();
        });

        element.addEventListener('click', (event) => {
          event.preventDefault();
        });
      }

      function lerpWrapped(from, to, t) {
        let delta = to - from;
        const halfBoard = CELLS / 2;

        if (delta > halfBoard) delta -= CELLS;
        if (delta < -halfBoard) delta += CELLS;

        return (from + delta * t + CELLS) % CELLS;
      }

      function interpolatedSnake(progress) {
        if (!previousSnake.length) return snake;

        const t = Math.max(0, Math.min(1, progress));
        if (t >= 1) return snake;

        return snake.map((segment, index) => {
          const from = previousSnake[Math.min(index, previousSnake.length - 1)] || segment;

          return {
            x: lerpWrapped(from.x, segment.x, t),
            y: lerpWrapped(from.y, segment.y, t)
          };
        });
      }

      function spawnFoodBurst(cellX, cellY, isSpecial = false) {
        const centerX = cellX * GRID + GRID / 2;
        const centerY = cellY * GRID + GRID / 2;
        const totalParticles = isSpecial ? 30 : 18;
        const palette = isSpecial
          ? ['#fff5b6', '#ffd264', '#ffab4f', '#8df4ff']
          : ['#ffe092', '#ffc65a', '#ff915f'];

        for (let i = 0; i < totalParticles; i++) {
          const angle = (Math.PI * 2 * i) / totalParticles + Math.random() * 0.18;
          const velocity = (isSpecial ? 1.8 : 1.1) + Math.random() * (isSpecial ? 3.2 : 2.4);
          const life = (isSpecial ? 560 : 420) + Math.random() * (isSpecial ? 420 : 320);

          particles.push({
            x: centerX,
            y: centerY,
            vx: Math.cos(angle) * velocity,
            vy: Math.sin(angle) * velocity,
            size: 1.8 + Math.random() * 2.8,
            life,
            maxLife: life,
            color: palette[i % palette.length]
          });
        }
      }

      function step() {
        if (!started || paused || gameOver) return;
        previousSnake = snake.map((segment) => ({ x: segment.x, y: segment.y }));
        const now = performance.now();
        updateSpecialFoodExpiry(now);

        if (directionQueue.length) {
          direction = directionQueue.shift();
        }

        const head = {
          x: (snake[0].x + direction.x + CELLS) % CELLS,
          y: (snake[0].y + direction.y + CELLS) % CELLS
        };

        const willEatRegular = head.x === food.x && head.y === food.y;
        const willEatSpecial = Boolean(specialFood && head.x === specialFood.x && head.y === specialFood.y);
        const willGrow = willEatRegular || willEatSpecial;
        const bodyToCheck = willGrow ? snake : snake.slice(0, -1);
        const hitSelf = bodyToCheck.some((segment) => segment.x === head.x && segment.y === head.y);

        if (hitSelf) {
          endRound(false);
          return;
        }

        snake.unshift(head);

        if (willEatRegular) {
          score += REGULAR_FOOD_POINTS;
          spawnFoodBurst(head.x, head.y, false);
          spawnFood();
          spawnSpecialFood(now);

          if (gameOver) {
            renderHud();
            lastStepAt = performance.now();
            return;
          }
        }

        if (willEatSpecial) {
          score += SPECIAL_FOOD_POINTS;
          spawnFoodBurst(head.x, head.y, true);
          specialFood = null;
        }

        if (!willGrow) {
          snake.pop();
        }

        renderHud();
        lastStepAt = performance.now();
      }

      function endRound(didWin) {
        gameOver = true;
        stopTickLoop();

        let newHighScore = false;
        if (score > highScores[currentMode]) {
          highScores[currentMode] = score;
          saveHighScores();
          renderHighScoreCards();
          newHighScore = true;
        }

        lastRun = { score, mode: currentMode };
        renderLastRun();
        renderHud();

        if (didWin) {
          overlayTitle = 'Board Cleared';
          overlaySubtitle = 'You filled every tile. Press R to run it back.';
        } else if (newHighScore) {
          overlayTitle = 'New High Score';
          overlaySubtitle = `${MODES[currentMode].label} best is now ${score}.`;
        } else {
          overlayTitle = 'Game Over';
          overlaySubtitle = 'Press R to restart or M for menu.';
        }
      }

      function roundedRectPath(x, y, width, height, radius) {
        const r = Math.min(radius, width / 2, height / 2);

        if (typeof ctx.roundRect === 'function') {
          ctx.beginPath();
          ctx.roundRect(x, y, width, height, r);
          return;
        }

        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
      }

      function drawWrappedStroke(points, style, width, shadowColor = '', shadowBlur = 0) {
        if (points.length < 2) return;

        ctx.save();
        ctx.strokeStyle = style;
        ctx.lineWidth = width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (shadowColor) {
          ctx.shadowColor = shadowColor;
          ctx.shadowBlur = shadowBlur;
        }

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        for (let i = 1; i < points.length; i++) {
          const point = points[i];
          const previous = points[i - 1];
          const wrappedJump =
            Math.abs(point.x - previous.x) > WRAP_GAP_THRESHOLD ||
            Math.abs(point.y - previous.y) > WRAP_GAP_THRESHOLD;

          if (wrappedJump) {
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(point.x, point.y);
            continue;
          }

          ctx.lineTo(point.x, point.y);
        }

        ctx.stroke();
        ctx.restore();
      }

      function drawStarPath(cx, cy, spikes, outerRadius, innerRadius, rotation = 0) {
        const step = Math.PI / spikes;
        let angle = rotation - Math.PI / 2;

        ctx.beginPath();
        for (let i = 0; i < spikes * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const x = cx + Math.cos(angle) * radius;
          const y = cy + Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          angle += step;
        }
        ctx.closePath();
      }

      function drawBoardBackground(time) {
        const gradient = ctx.createLinearGradient(0, 0, BOARD, BOARD);
        gradient.addColorStop(0, boardTheme.bgA);
        gradient.addColorStop(1, boardTheme.bgB);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, BOARD, BOARD);

        const sweep = ctx.createLinearGradient(-BOARD * 0.8, 0, BOARD * 1.8, BOARD);
        const sweepCenter = 0.2 + ((Math.sin(time * 0.0004) + 1) * 0.5) * 0.58;
        sweep.addColorStop(Math.max(0, sweepCenter - 0.22), 'rgba(255, 255, 255, 0)');
        sweep.addColorStop(sweepCenter, boardTheme.sweep);
        sweep.addColorStop(Math.min(1, sweepCenter + 0.22), 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = sweep;
        ctx.fillRect(0, 0, BOARD, BOARD);

        for (let y = 0; y < CELLS; y++) {
          for (let x = 0; x < CELLS; x++) {
            if ((x + y) % 2 === 0) {
              ctx.fillStyle = boardTheme.checker;
              ctx.fillRect(x * GRID, y * GRID, GRID, GRID);
            }
          }
        }

        ctx.strokeStyle = boardTheme.grid;
        ctx.lineWidth = 1;
        for (let i = 0; i <= CELLS; i++) {
          const p = i * GRID;
          ctx.beginPath();
          ctx.moveTo(p, 0);
          ctx.lineTo(p, BOARD);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, p);
          ctx.lineTo(BOARD, p);
          ctx.stroke();
        }

        for (let i = 0; i < 28; i++) {
          const anchorX = ((i * 61) % BOARD) + 8;
          const anchorY = ((i * 97) % BOARD) + 8;
          const pulse = 0.35 + 0.65 * (0.5 + 0.5 * Math.sin(time * 0.002 + i * 1.3));
          const x = (anchorX + Math.sin(time * 0.0008 + i) * 6 + BOARD) % BOARD;
          const y = (anchorY + Math.cos(time * 0.0009 + i * 0.8) * 6 + BOARD) % BOARD;
          ctx.globalAlpha = 0.12 * pulse;
          ctx.fillStyle = boardTheme.spark;
          ctx.beginPath();
          ctx.arc(x, y, 0.8 + pulse * 0.9, 0, TAU);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        const vignette = ctx.createRadialGradient(
          BOARD / 2,
          BOARD / 2,
          BOARD / 5,
          BOARD / 2,
          BOARD / 2,
          BOARD * 0.82
        );
        vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
        vignette.addColorStop(1, boardTheme.vignette);
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, BOARD, BOARD);

        ctx.strokeStyle = boardTheme.frame;
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, BOARD - 2, BOARD - 2);
      }

      function drawFood(time) {
        const centerX = food.x * GRID + GRID / 2;
        const centerY = food.y * GRID + GRID / 2;
        const pulse = 0.9 + 0.12 * Math.sin(time * 0.014);
        const bob = Math.sin(time * 0.008 + food.x * 0.5 + food.y * 0.35) * 0.9;

        ctx.save();
        ctx.translate(centerX, centerY + bob);

        ctx.shadowColor = 'rgba(255, 118, 97, 0.72)';
        ctx.shadowBlur = 18;

        ctx.strokeStyle = 'rgba(255, 204, 136, 0.45)';
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.arc(0, 0, GRID * 0.54 + Math.sin(time * 0.01) * 1.8, 0, TAU);
        ctx.stroke();

        const body = ctx.createRadialGradient(
          -2,
          -4,
          GRID * 0.12,
          0,
          0,
          GRID * 0.54
        );
        body.addColorStop(0, '#fff5c4');
        body.addColorStop(0.35, '#ffc565');
        body.addColorStop(1, '#ff715b');
        ctx.fillStyle = body;

        ctx.beginPath();
        ctx.arc(0, 0, GRID * 0.34 * pulse, 0, TAU);
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.55)';
        ctx.beginPath();
        ctx.arc(-4, -4, 2.8, 0, TAU);
        ctx.fill();

        ctx.fillStyle = '#6fdd98';
        roundedRectPath(-1.5, -11.5, 3, 6.5, 1.2);
        ctx.fill();

        ctx.fillStyle = '#8be8b0';
        ctx.beginPath();
        ctx.ellipse(3.2, -9.5, 5.8, 2.8, -0.45, 0, TAU);
        ctx.fill();

        ctx.restore();
      }

      function drawSpecialFood(time) {
        if (!specialFood) return;

        const centerX = specialFood.x * GRID + GRID / 2;
        const centerY = specialFood.y * GRID + GRID / 2;
        const pulse = 0.9 + 0.18 * Math.sin(time * 0.02);
        const remaining = Math.max(0, specialFood.expiresAt - time);
        const progress = remaining / SPECIAL_FOOD_DURATION_MS;
        const spin = time * 0.0032;

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.shadowColor = 'rgba(255, 223, 94, 0.9)';
        ctx.shadowBlur = 22;

        const body = ctx.createRadialGradient(-2, -4, GRID * 0.1, 0, 0, GRID * 0.58);
        body.addColorStop(0, '#fff8cd');
        body.addColorStop(0.42, '#ffd85f');
        body.addColorStop(1, '#ff9d2e');
        ctx.fillStyle = body;

        drawStarPath(0, 0, 6, GRID * 0.39 * pulse, GRID * 0.2 * pulse, spin);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255, 244, 173, 0.95)';
        ctx.lineWidth = 2.1;
        ctx.beginPath();
        ctx.arc(
          0,
          0,
          GRID * 0.48,
          -Math.PI / 2,
          -Math.PI / 2 + TAU * progress
        );
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.beginPath();
        ctx.arc(-3.2, -4.8, 2.8, 0, TAU);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255, 247, 204, 0.9)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.arc(0, 0, GRID * 0.28 + Math.sin(time * 0.01) * 1.2, 0, TAU);
        ctx.stroke();
        ctx.restore();
      }

      function drawSnake(time, snakeToRender) {
        if (!snakeToRender.length) return;

        const config = MODES[currentMode];
        const centers = snakeToRender.map((segment) => ({
          x: segment.x * GRID + GRID / 2,
          y: segment.y * GRID + GRID / 2
        }));
        const head = centers[0];
        const tail = centers[centers.length - 1];

        const bodyGradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
        bodyGradient.addColorStop(0, `hsl(${config.hue} 94% 63%)`);
        bodyGradient.addColorStop(0.42, `hsl(${(config.hue + 18) % 360} 86% 54%)`);
        bodyGradient.addColorStop(1, `hsl(${(config.hue + 36) % 360} 72% 38%)`);

        drawWrappedStroke(
          centers,
          bodyGradient,
          GRID * 0.76,
          `hsla(${config.hue}, 92%, 60%, 0.45)`,
          15
        );

        const highlightGradient = ctx.createLinearGradient(head.x, head.y - GRID, tail.x, tail.y + GRID);
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.36)');
        highlightGradient.addColorStop(0.45, 'rgba(255, 255, 255, 0.1)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0.04)');
        drawWrappedStroke(centers, highlightGradient, GRID * 0.4);

        const headRadius = GRID * (0.34 + 0.03 * Math.sin(time * 0.015));
        const forwardX = direction.x || 1;
        const forwardY = direction.y || 0;
        const sideX = -forwardY;
        const sideY = forwardX;

        ctx.save();
        ctx.shadowColor = `hsla(${config.hue}, 100%, 70%, 0.55)`;
        ctx.shadowBlur = 18;
        const headFill = ctx.createRadialGradient(
          head.x - forwardX * 2,
          head.y - forwardY * 2,
          GRID * 0.06,
          head.x,
          head.y,
          GRID * 0.5
        );
        headFill.addColorStop(0, `hsl(${config.hue} 100% 76%)`);
        headFill.addColorStop(0.65, `hsl(${(config.hue + 10) % 360} 92% 58%)`);
        headFill.addColorStop(1, `hsl(${(config.hue + 18) % 360} 78% 44%)`);
        ctx.fillStyle = headFill;
        ctx.beginPath();
        ctx.arc(head.x, head.y, headRadius, 0, TAU);
        ctx.fill();
        ctx.restore();

        const eyeForward = headRadius * 0.42;
        const eyeSide = headRadius * 0.46;
        const leftEyeX = head.x + forwardX * eyeForward + sideX * eyeSide;
        const leftEyeY = head.y + forwardY * eyeForward + sideY * eyeSide;
        const rightEyeX = head.x + forwardX * eyeForward - sideX * eyeSide;
        const rightEyeY = head.y + forwardY * eyeForward - sideY * eyeSide;
        const pupilShift = headRadius * 0.2;

        ctx.fillStyle = 'rgba(240, 251, 255, 0.98)';
        ctx.beginPath();
        ctx.arc(leftEyeX, leftEyeY, 2.8, 0, TAU);
        ctx.arc(rightEyeX, rightEyeY, 2.8, 0, TAU);
        ctx.fill();

        ctx.fillStyle = '#082739';
        ctx.beginPath();
        ctx.arc(leftEyeX + forwardX * pupilShift, leftEyeY + forwardY * pupilShift, 1.35, 0, TAU);
        ctx.arc(rightEyeX + forwardX * pupilShift, rightEyeY + forwardY * pupilShift, 1.35, 0, TAU);
        ctx.fill();

        if (Math.sin(time * 0.023) > 0.86) {
          const tongueStartX = head.x + forwardX * (headRadius + 1);
          const tongueStartY = head.y + forwardY * (headRadius + 1);
          const tongueTipX = tongueStartX + forwardX * 8;
          const tongueTipY = tongueStartY + forwardY * 8;
          const forkOffsetX = sideX * 1.8;
          const forkOffsetY = sideY * 1.8;

          ctx.strokeStyle = 'rgba(255, 123, 117, 0.9)';
          ctx.lineWidth = 1.6;
          ctx.beginPath();
          ctx.moveTo(tongueStartX, tongueStartY);
          ctx.lineTo(tongueTipX, tongueTipY);
          ctx.moveTo(tongueTipX, tongueTipY);
          ctx.lineTo(tongueTipX + forkOffsetX, tongueTipY + forkOffsetY);
          ctx.moveTo(tongueTipX, tongueTipY);
          ctx.lineTo(tongueTipX - forkOffsetX, tongueTipY - forkOffsetY);
          ctx.stroke();
        }
      }

      function updateParticles(deltaMs) {
        if (!particles.length) return;

        const updated = [];
        const delta = deltaMs / 16.666;

        for (const particle of particles) {
          particle.life -= deltaMs;
          if (particle.life <= 0) continue;

          particle.x += particle.vx * delta;
          particle.y += particle.vy * delta;
          particle.vx *= 0.985;
          particle.vy *= 0.985;
          particle.vy += 0.05 * delta;

          updated.push(particle);
        }

        particles = updated;
      }

      function drawParticles() {
        if (!particles.length) return;

        for (const particle of particles) {
          const alpha = Math.max(0, particle.life / particle.maxLife);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = particle.color;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.globalAlpha = 1;
      }

      function drawOverlay(title, subtitle) {
        const dimmer = theme === 'dark' ? 'rgba(2, 10, 22, 0.66)' : 'rgba(24, 52, 80, 0.42)';
        ctx.fillStyle = dimmer;
        ctx.fillRect(0, 0, BOARD, BOARD);

        const cardWidth = BOARD * 0.78;
        const cardHeight = 138;
        const cardX = (BOARD - cardWidth) / 2;
        const cardY = BOARD / 2 - cardHeight / 2;

        const cardFill = ctx.createLinearGradient(cardX, cardY, cardX, cardY + cardHeight);
        if (theme === 'dark') {
          cardFill.addColorStop(0, 'rgba(10, 28, 46, 0.9)');
          cardFill.addColorStop(1, 'rgba(8, 20, 35, 0.9)');
        } else {
          cardFill.addColorStop(0, 'rgba(248, 253, 255, 0.92)');
          cardFill.addColorStop(1, 'rgba(232, 245, 255, 0.9)');
        }

        roundedRectPath(cardX, cardY, cardWidth, cardHeight, 16);
        ctx.fillStyle = cardFill;
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.strokeStyle = theme === 'dark'
          ? 'rgba(138, 205, 255, 0.34)'
          : 'rgba(64, 124, 176, 0.3)';
        ctx.stroke();

        ctx.textAlign = 'center';
        ctx.fillStyle = theme === 'dark' ? '#e8f3ff' : '#184365';
        ctx.font = "800 34px 'Orbitron', sans-serif";
        ctx.fillText(title, BOARD / 2, cardY + 56);

        ctx.fillStyle = theme === 'dark' ? '#bfd6ee' : '#3f668b';
        ctx.font = "700 15px 'Manrope', sans-serif";
        ctx.fillText(subtitle, BOARD / 2, cardY + 90);
      }

      function renderFrame(time) {
        const delta = Math.min(34, time - lastFrameTime);
        lastFrameTime = time;
        updateSpecialFoodExpiry(time);

        updateParticles(delta);

        ctx.clearRect(0, 0, BOARD, BOARD);
        drawBoardBackground(time);

        if (started) {
          const snakeProgress = paused || gameOver
            ? 1
            : Math.max(0, Math.min(1, (time - lastStepAt) / Math.max(speed, 1)));
          const snakeToRender = interpolatedSnake(snakeProgress);
          drawFood(time);
          drawSpecialFood(time);
          drawSnake(time, snakeToRender);
          drawParticles();
        }

        if (started && paused && !gameOver) {
          drawOverlay('Paused', 'Press Space to resume');
        }

        if (started && gameOver) {
          drawOverlay(overlayTitle, overlaySubtitle);
        }

        animationFrame = requestAnimationFrame(renderFrame);
      }

      function handleModeClick(event) {
        const mode = event.currentTarget.dataset.mode;
        if (!mode || mode === currentMode) return;

        setMode(mode);
        if (started) {
          resetRound();
        }
      }

      modeButtons.forEach((button) => {
        button.addEventListener('click', handleModeClick);
      });

      startBtn.addEventListener('click', startGame);

      restartBtn.addEventListener('click', () => {
        if (!started) {
          startGame();
          return;
        }
        resetRound();
      });

      menuBtn.addEventListener('click', showMenu);
      themeToggleMenuBtn.addEventListener('click', toggleTheme);
      themeToggleHudBtn.addEventListener('click', toggleTheme);

      touchDirectionButtons.forEach((button) => {
        bindTouchControl(button, () => {
          setDirectionFromToken(button.dataset.touchDir);
        });
      });

      document.addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();

        if (key === 'arrowup' || key === 'w') {
          setDirection({ x: 0, y: -1 });
          event.preventDefault();
        }
        if (key === 'arrowdown' || key === 's') {
          setDirection({ x: 0, y: 1 });
          event.preventDefault();
        }
        if (key === 'arrowleft' || key === 'a') {
          setDirection({ x: -1, y: 0 });
          event.preventDefault();
        }
        if (key === 'arrowright' || key === 'd') {
          setDirection({ x: 1, y: 0 });
          event.preventDefault();
        }

        if (key === ' ') {
          togglePause();
          event.preventDefault();
        }

        if (key === 'r') {
          if (started) {
            resetRound();
          }
        }

        if (key === 'm') {
          showMenu();
        }

        if (key === 't') {
          toggleTheme();
        }

        if (key === 'enter') {
          if (!started) {
            startGame();
          } else if (gameOver) {
            resetRound();
          }
        }
      });

      applyTheme(detectInitialTheme());
      syncTouchMode();
      window.addEventListener('resize', syncTouchMode);
      window.addEventListener('orientationchange', syncTouchMode);
      setMode('medium');
      renderHighScoreCards();
      renderLastRun();
      renderHud();
      showMenu();
      animationFrame = requestAnimationFrame(renderFrame);

      window.addEventListener('beforeunload', () => {
        stopTickLoop();
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
      });
    })();
  </script>
</body>
</html>
